\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\newcommand{\cit}[1]{{\fontfamily{qcr}\selectfont{\textit{\textbf{\textcolor{darkgray}{#1}}}}}}

% Taken from Lena Herrmann at 
% http://lenaherrmann.net/2010/05/20/javascript-syntax-highlighting-in-the-latex-listings-package
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}

\title{Async Tree Pattern}
\author{Guseyn Ismayylov}
\date{July 2018}

\begin{document}

\maketitle

\section{Introduction}

\textbf{Async Tree Pattern} is a declarative design pattern, the main purpose of which is to transform procedural code into the object-oriented(declarative) code in the asynchronous environment (in this work implementation of this pattern will be shown for Node.js).

Also \textbf{Async Tree} can be considered as a data structure.
\section{Declarative vs Imperative}

The conception of the \textbf{Async Tree} was created with assumption that declarative programming is much better than imperative style of writing code for big programs and systems. Declarative code is more readable, extensible and maintainable in general.

You may agree or disagree with this statement. It's only opinion of the author of this work.

Here it will be shown the difference between these two approaches by small example. Let's consider the following imperative code:  

\begin{lstlisting}

// Imperative
user = getUserFromDb(userId);
account = user.createNewAccount(accountInfo);
user.saveAccount(account);

\end{lstlisting}

It can be written in the declarative style:

\begin{lstlisting}

// Declarative
SavedAccount(
  CreatedAccount(
    UserFromDb(userId), accountInfo
  )
).call();

\end{lstlisting}

The example is quite small to demonstrate why declarative programming is preferable. Nevertheless, you can see that declarative code always shows the result of program execution and what it requires to get this result. For readability it's more important to be able to see what result you get, not how exactly you get it.

\section{Why Node.js}

As it's been said the implementation of the \textbf{Async Tree} will be described for Node.js. The choice is very simple because Node.js is the most popular and stable asynchronous  event driven runtime and it performs well. But as you will see, \textbf{Async Tree} can be applied not only in the asynchronous environment.

\section{Async Tree and Async Object}

\textbf{Async Tree} can be defined as a composition of objects and primitives. Each of objects in this composition that represents some other object or primitive type of data is called \textbf{Async Object}. 

For example, in the previous example \cit{SavedAccount} and \cit{CreatedAccount} represent \cit{Account}, \cit{UserFromDb} represents \cit{User}.

\textbf{Async Object} is an object that represents(computes) some other but similar(in terms of logic) object. So, for example, \cit{SavedAccount}, \cit{UpdatedAccount}, \cit{DeletedAccount} are \textit{async objects} because they represent \cit{Account}, which is simple object. \cit{UserFromDb}, \cit{UserFromRequest} are also \textit{async objects}, they represent simple object \cit{User}.

Every \textbf{Async Object} can be constructed by other \textit{async objects}, \textit{simple objects} and \textit{primitives}. For example, \cit{SavedAccount} can be created by \cit{UpdatedAccount}, \cit{CreatedAccount} or any other \cit{Async Object} that represents \cit{Account}. Obviously, it can be created by \cit{Account} itself.

That's the main idea of the \textbf{Async Tree Pattern}: to provide flexible way to create composition of objects via their representations.

\section{Asynchronous environment and \textit{callback hell}}

If you're familiar with Node.js and how it works, you might know about \textit{callback hell} problem. Callbacks is the main feature and problem in Node.js. Although it's a beautiful abstraction, it decreases readability of a program while it grows up.

Actually, \textit{callback hell} is one of the reasons why \textbf{Async Tree Pattern} was created. There are relatively new conceptions in JavaScript like Promises and async/await. But in my opinion, these abstractions are not suitable for object-oriented style. Simply because they don't provide the main feature of OOP: encapsulation. 
It's not possible to create a composition of objects and write declarative code with these abstractions.

Node.js is a set of modules with static asynchronous methods. And this is main problem - static methods are not actually attached to any objects. They just exists in namespaces such as fs(Node.js module for file system), http, stream, buffer and so on.

Static methods with callbacks don't allow to use results of their execution for other operations in the explicit way. The more asynchronous calls in code, the harder to control flow of data there.

Let's say we want to write content to a file that has been read from another one. And all these operations are asynchronous, of course. So, instead of writing something like this:

\begin{lstlisting}

fs.readFile('./../file1.txt', 'utf8', (err, result) => {
  if (err != null) {
    throw err;
  }
 
  fs.writeFile('/../file2.txt', result, (err) => {
    if (err != null) {
      throw err;
    }
  });
});

\end{lstlisting}

we can design our code in the following style:

\begin{lstlisting}

new WrittenFile(
  './../file2.txt',
  new ReadContentFromFile('./../file1.txt', 'utf8')
).call();

\end{lstlisting}

As you can see, we use \textit{async objects} instead of \textit{async calls} and their representations as results of operations they correspond to. So, \cit{ReadContentFromFile} represents \cit{string} - content from a file, which is result of \textit{async call} \cit{fs.readFile}. And \cit{WrittenFile} represents a file that has been written with some content. Although \cit{fs.WriteFile} does not return anything, we can use \cit{WrittenFile} as file for other operations if it's needed.

\section{Features of the Async Tree Pattern}

\subsection{Flexibility}

The main question needs to be answered for turning asynchronous code into OOP code is \textit{"What is the main point of doing async call?"}

Well, it's simple: receive a result from an I/O operation or just handle an error in case if something fails. That means that we can represent an I/O call as a result that can be received in the future, and when it's ready it can be used as argument for another async call.

Let's return back to the example with reading and writing files. Objects \cit{WrittenFile} and \cit{ReadContentFromFile} are async objects, and they have the same arguments that their corresponding async calls have. So, here the first argument of \cit{WrittenFile} is a path of a file we want to write content to, second one is the content we want to write. And as you noticed, second argument is represented here as \cit{ReadContentFromFile}. It means that method \cit{call()} of \cit{WrittenFile} invoke first \cit{ReadContentFromFile} and use its result as content for \cit{WrittenFile}.

It's good, but it could be better. For making this declarative abstraction flexible we need a possibility to use either ready results or \textit{async objects} that represent these results as arguments for construction the whole composition.

For example, we can use second argument of \cit{WrittenFile} as a string:

\begin{lstlisting}

new WrittenFile('./../file2.txt', 'content to write').call();

\end{lstlisting}
or use the fist argument as something that has been read from another file:

\begin{lstlisting}

/* here file3.txt contains information 
  for the first argument of WrittenFile: './../file2.txt' */
new WrittenFile(
  new ReadContentFromFile('./../file3.txt', 'utf8'), 
  new ReadContentFromFile('./../file1.txt', 'utf8')
).call();

\end{lstlisting}
or even just use every async object independently:

\begin{lstlisting}

new ReadContentFromFile('./../file.txt', 'utf8').call();

\end{lstlisting}

That's how we can get rid of callbacks.

\subsection{Events}

There is another abstraction in Node that must be considered. And this is \textit{events}. It's not something that can be implemented via \textbf{Async Object} abstraction.

Let's look at the most popular example in Node:

\begin{lstlisting}

http.createServer((request, response) => {

  // send back a response every time you get a request

}).listen(8080, '127.0.0.1', () => {
  'server is listening on 127.0.0.1:8080'
});

\end{lstlisting}

Here method \cit{createServer} use \textit{request listener} as argument, which actually works like an \textit{event}: on every \textit{request} it provides a  \textit{response}. Unlike simple \textit{async call}, \textit{event} is never finished and it's being invoked every time when it's needed.

It can be rewritten in the following declarative way:

\begin{lstlisting}

new LoggedListeningServer(
  new ListeningServer(
    new CreatedServer(
      new RequestResponseEvent()
    ), 8080, '127.0.0.1'
  ), 'server is listening on 127.0.0.1:8080'
).call();

\end{lstlisting}

As you can see, \cit{RequestResponseEvent} is a node in the \textbf{Async Tree} that represents \textit{request listener}, but it's not a simple argument or \textbf{Async Object}. \cit{RequestResponseEvent} implements \cit{Event} interface and it needs to be treated in a special way, so it requires more flexibility of the whole system.

\subsection{Sequence of async trees}

Sometimes it's not so easy to make a proper composition of \textit{async objects} (or just any kind of objects), mostly because sometimes we need to do completely different things at different moments. And if you try to combine these things in one \textit{async tree}, you'll probably fail. So it would be very useful to be able call one \textit{async tree} after another one. For example,

\begin{lstlisting}

new EqualAssertion(
  new ReadContentFromFile(
    new WrittenFile('./text.txt', 'content')
  ), 'content'
).after(
  RemovedFile('./text.txt')
).call();

\end{lstlisting}

It's a test that checks that read content from a file is equal to the content that has been written to the file. After test the file can be removed to free space on a disk.

Method \cit{after} can be used only once for every async tree:

\begin{lstlisting}

// RIGHT WAY, pseudocode
AsyncTree1().after(
  AsyncTree2().after(
    AsyncTree3().after(...)
  )
)

// WRONG WAY, pseudocode
AsyncTree1().after(
  AsyncTree2()
).after(
  AsyncTree3()
).after(...)

\end{lstlisting}

\subsection{Cache mechanism}

Consider the following example with  \textit{async tree}:

\begin{lstlisting}

new SavedNewAccountOfUser(
  new RetrievedUser(userId),
  new RetrievedOldAccountOfUser(
    new RetrievedUser(userId)
  )
).call();

\end{lstlisting}

So, here we try to save new account for user that based(somehow) on its old one. And as you can see, we \textit{retrieve user} here twice. \cit{RetrievedUser} can be a quite expensive operation, so we don't want to do it more than one time. So, what would do you do here?

\newpage

Well, you definitely don't want to do something like this:

\begin{lstlisting}

const retrievedUser = new RetrievedUser(userId);
new SavedNewAccountOfUser(
  retrievedUser,
  new RetrievedOldAccountOfUser(
    retrievedUser
  )
).call();

\end{lstlisting}

Because it does not change anything. All these objects are asynchronous, they are not simple procedures, and all them will be invoked only when they are needed in the \textit{async tree}. It means that the results they produce could be recieved and used only in the inner scope of the \textit{tree}.

Another thing you must consider here is which of two \cit{RetrievedUser} will be invoked first, so that you can write its result into the cache for using it for the second \cit{RetrievedUser}.

Here \textit{sequence of async trees} can help to create declarative construction for caching:

\begin{lstlisting}

new RetrievedUser(userId).as('user')
  .after(
    new SavedNewAccountOfUser(
      as('user'),
      new RetrievedOldAccountOfUser(
        as('user')
      )
    )
  ).call();
  
\end{lstlisting}

Every \textbf{Async Object} can has \cit{as(key)} method, which says to the \textbf{Async Object} that it must save its represented value(result) into the cache with the specified \textit{key}. \cit{as(key)} method is used as independent(separate) function, it returns AsyncObject that represents value from the cache with the specified \textit{key}.

\section{Implementation of the Async Tree}

\subsection{How it works}

// TODO

\subsection{Show me the code}

For implementation \textbf{Aync Tree Pattern} we need following classes(abstractions): \cit{AsyncObject}, \cit{AsyncTree},
\cit{TreeNode}, \cit{SimpleTreeNode}, \cit{AsyncTreeNode}, \cit{NotDefinedAsyncTreeNode}, \cit{Event}, \cit{As} and \cit{NullError}.

\subsection{AsyncObject}

\cit{AsyncObject} has three types of methods: methods that must be(or can be) implemented by classes that extend it, methods that can be used in declarative composition and methods that are not allowed to be overridden. Also \cit{AsyncObject} has constructor.

\newpage

\subsubsection{Constructor}

\begin{lstlisting}

constructor(...args) {
  this.args = args;
  this.tree = new AsyncTree(this);
  this.next;
  this.cache = {};
  this.asKey;
}

\end{lstlisting}
\cit{...args} can be any type, including \cit{AsyncObject}. Every \cit{AsyncObject} encapsulates \cit{tree} that use it as root field. Argument \cit{next} points to the next \textit{async tree} if it set by \cit{after} method, by default it's undefined. Also every \textit{async object} has \cit{cache} that is simple map. It's needed because cache must be visible in the global scope. Field \textit{asKey} is used as a key for saving representation(computing result) of \textit{async object} into the cache if method \cit{as} is invoked.

\vspace*{10px}

\subsubsection{Methods for implementing}

\begin{lstlisting}
definedAsyncCall() {
  throw new Error('asyncCall or syncCall must be defined');
}

definedSyncCall() {
  throw new Error('asyncCall or syncCall must be defined');
}

onError(error) {
  throw error;
}

onResult(result) {
  return result;
}

onErrorAndResult(error, result) {
  return error || result;
}

continueAfterFail() {
  return false;
}

callbackWithError() {
  return true;
}
\end{lstlisting}

Either of methods definedAsyncCall or definedSyncCall must be defined (implemented) in extended classes. If both of them are implemented then only \cit{definedAsyncCall} will be invoked. The entire logic of using these methods will be show in \cit{AsyncTreeNode} class.

Method \cit{onError} is used as handler for errors that might happen in \textit{async calls}. And \cit{onResult} is used for post processing result of \textit{async call}.

If \cit{continueAfterResult} returns true, then \cit{onError} and \cit{onResult} will be ignored, and the represented result of \textit{async object} will be returned by \cit{onErrorAndResult}.

Method \cit{callbackWithError} must return \cit{true} if an error is expected in a callback of corresponding \textit{async call}, otherwise it must return \cit{false}.

\vspace*{10px}

\subsubsection{Methods from public API}

\begin{lstlisting}

call() {
  this.propagateCache(this);
  this.tree.create().call();
}

after(asyncObject) {
  this.next = asyncObject;
  return this;
}

as(key) {
  this.asKey = key;
  return this;
}

\end{lstlisting}

Method \cit{call} is being invoked only of \textit{async object} that is root of \textit{async tree}. It propagates cache among all fields, so it will be able to access cache in every \textit{asyn object} in the composition.

Method \cit{after} sets next \textit{async tree} that is invoked after the current one and returns this \textit{async object}. Obviously, this method can be used only for the root \textit{async object}.

Method \cit{as} sets key for caching and return this \textit{async object}.

\vspace*{10px}

\subsubsection{Internal methods (not for overriding)}

\begin{lstlisting}

iterateArgs(func) {
  this.args.forEach((arg, index) => {
    let isAsync = arg instanceof AsyncObject;
    let isEvent = arg instanceof Event;
    func(arg, index, isAsync, isEvent);
  });
}

hasNoArgs() {
  return this.args.length === 0;
}

readyToBeInvoked(readyResultsNum) {
  return this.args.length === readyResultsNum;
}

callNextTreeIfExists() {
  if (this.next) {
    this.propagateCache(this.next);
    new AsyncTree(this.next).create().call();
  }
}

propagateCache(arg) {
  if (arg instanceof AsyncObject) {
    arg.withCache(this.cache);
    arg.iterateArgs(
      arg => this.propagateCache(arg)
    );
  }
}

withCache(cache) {
  this.cache = cache;
  return this;
 }
 
saveValueIntoCacheIfNeeded(value) {
  if (this.asKey) {
    this.cache[this.asKey] = value;
  }
  return this;
}

\end{lstlisting}

Method \cit{iterateArgs} is a proxy method, which avoid using \textit{getters} and \textit{setters} for processing args of \textit{async object}.

Method \cit{hasNoArgs} checks if \textit{async object} encapsulates anything.



\end{document}
