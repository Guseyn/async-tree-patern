\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}
\graphicspath{ {./img/} }
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{superlightgray}{rgb}{0.97,0.97,0.97}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{superdarkgray}{rgb}{.2,.2,.2}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\newcommand{\cit}[1]{{\fontfamily{qcr}\selectfont{\textcolor{purple}{\colorbox{superlightgray}{#1}}}}}
\newcommand{\bit}[1]{\textit{\textbf{#1}}}

% Taken from Lena Herrmann at 
% http://lenaherrmann.net/2010/05/20/javascript-syntax-highlighting-in-the-latex-listings-package
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}

\title{Async Tree Pattern}
\author{Guseyn Ismayylov}
\date{July 2018}

\begin{document}

\maketitle

\section{Introduction}

\textbf{Async Tree Pattern} is a declarative design pattern, the main purpose of which is to transform procedural code into the object-oriented(declarative) code in the asynchronous environment via \textbf{async tree}, which is the core idea of this pattern.

\section{Declarative vs Imperative}

The conception of the \textit{async tree} was created with assumption that declarative programming is much better than imperative style of writing code for big programs and systems. Declarative code is more readable, extensible and maintainable in general.

You may agree or disagree with this statement. It's only opinion of the author of this work.

Here it will be shown the difference between these two approaches by small example. Let's consider the following imperative code:  

\begin{lstlisting}
// Imperative, pseudocode
user = getUserFromDb(userId);
account = user.createNewAccount(accountInfo);
user.saveAccount(account);
\end{lstlisting}

It can be written in the declarative style:

\begin{lstlisting}
// Declarative, pseudocode
SavedAccount(
  CreatedAccount(
    UserFromDb(userId), accountInfo
  )
).call();
\end{lstlisting}

The example is quite small to demonstrate why declarative programming is preferable. Nevertheless, you can see that declarative code always shows the result of program execution and what it requires to get this result. For readability it's more important to be able to see what result you get, not how exactly you get it.

\section{Composition of async objects}

The last example with the declarative code is actually a composition of \textbf{async objects}.

\textbf{Async object} is an object that represents(computes) some other(but similar in terms of logic) object. Also async object can represent primitive type of data.

So, for example, \cit{SavedAccount}, \cit{CreatedAccount} are async objects because they represent \cit{Account}, which is simple object. \cit{UserFromDb} is also an async object, it represents simple object \cit{User}.

Async object also can be defined as a wrapper around some \textit{async call} or \textit{sync call} that computes its representation (why not to use separate abstraction like \textbf{sync object} for sync calls? well, it will be described later).

Every async object can be constructed by other async objects or representations of these async objects. For example, \cit{SavedAccount} can be created by \cit{CreatedAccount} or any other async object that represents \cit{Account}. Obviously, it can be created by \cit{Account} itself.

So, composition of async objects can also contain simple objects and primitives.

That's the main idea of the Async Tree Pattern: to provide flexible way to create composition of objects via their representations.

\section{Asynchronous environment and \textit{callback hell}}

The implementation of the Async Tree Pattern will be described for Node.js. The choice is very simple because Node.js is the most popular and stable asynchronous  event driven runtime and it performs well.

If you're familiar with Node.js and how it works, you might know about \textit{callback hell} problem. Callbacks is the main feature and problem in Node.js. Although it's a beautiful abstraction, it decreases readability of a program while it grows up.

Actually, callback hell is one of the reasons why Async Tree Pattern was created.

There are relatively new conceptions in JavaScript like \textit{Promises} and  \textit{async/ await}. But in my opinion, these abstractions are not suitable for object-oriented style. Simply because they don't provide the main feature of OOP: \textbf{encapsulation}. 
It's not possible to create a composition of objects and write declarative code with these abstractions.

Node.js is a set of modules with static asynchronous methods. And this is main problem - static methods are not actually attached to any objects. They just exists in namespaces such as fs, http, stream, buffer and so on.

Static methods with callbacks don't allow to use results of their execution for other operations in the explicit way. The more asynchronous calls in the code, the harder to control flow of data there.

Let's say we want to write content to a file that has been read from another one. And all these operations are asynchronous, of course. 
So, instead of writing something like this:

\begin{lstlisting}
fs.readFile('./../file1.txt', 'utf8', (err, result) => {
  if (err != null) {
    throw err;
  }
 
  fs.writeFile('/../file2.txt', result, (err) => {
    if (err != null) {
      throw err;
    }
  });
});
\end{lstlisting}

we can design our code in the following style:

\begin{lstlisting}
new WrittenFile(
  './../file2.txt',
  new ReadContentFromFile('./../file1.txt', 'utf8')
).call();
\end{lstlisting}

As you can see, we use async objects instead of async calls and their representations as results of operations they correspond to. So, \cit{ReadContentFromFile} represents \cit{string} - content from a file, which is the result of the async call \cit{fs.readFile}. And \cit{WrittenFile} represents a file that has been written with some content. Although \cit{fs.WriteFile} does not return anything, we can use \cit{WrittenFile} as a file for other operations if it's needed.

\section{Features of the Async Tree Pattern}

\subsection{Flexibility}

The main question needs to be answered for turning asynchronous code into the OOP code is \textit{"What is the main point of doing async call?"}

Well, it's simple: receive a result from an I/O operation or just handle an error in case if something fails. That means that we can represent an I/O call as a result that can be received in the future, and once it's ready it can be used as argument for another async call.

Let's return back to the example with reading and writing files. Objects \cit{WrittenFile} and \cit{ReadContentFromFile} are async objects, and they have the same arguments that their corresponding async calls have. So, here the first argument of \cit{WrittenFile} is a path of a file we want to write content to, second one is the content we want to write. And as you noticed, second argument is represented here as \cit{ReadContentFromFile}. It means that method \cit{call()} of \cit{WrittenFile} invoke first \cit{ReadContentFromFile} and use its result as content for \cit{WrittenFile}.

It's good, but it could be better. For making this declarative abstraction flexible we need a possibility to use either ready results or async objects that represent these results as arguments for construction the whole composition.

For example, we can use second argument of \cit{WrittenFile} as a string:

\begin{lstlisting}
new WrittenFile('./../file2.txt', 'content to write').call();
\end{lstlisting}
or use the fist argument as something that has been read from another file:
\begin{lstlisting}
/* here file3.txt contains information 
  for the first argument of WrittenFile: './../file2.txt' */
new WrittenFile(
  new ReadContentFromFile('./../file3.txt', 'utf8'), 
  new ReadContentFromFile('./../file1.txt', 'utf8')
).call();
\end{lstlisting}
or even just use every async object independently:

\begin{lstlisting}
new ReadContentFromFile('./../file.txt', 'utf8').call();
\end{lstlisting}

That's how we can get rid of callbacks.

\subsection{Events}

There is another abstraction in Node that must be considered. And this is \textit{events}. It's not something that can be implemented via async object abstraction.

Let's look at the most popular example in Node:

\begin{lstlisting}
http.createServer((request, response) => {

  // send back a response every time you get a request

}).listen(8080, '127.0.0.1', () => {
  'server is listening on 127.0.0.1:8080'
});
\end{lstlisting}

Here method \cit{createServer} uses \textit{request listener} as argument, which actually works like an event: on every \textit{request} it provides a  \textit{response}. Unlike simple async call, event is never finished and it's being invoked every time when it's needed.

It can be rewritten in the following declarative way:

\begin{lstlisting}
new LoggedListeningServer(
  new ListeningServer(
    new CreatedServer(
      new RequestResponseEvent()
    ), 8080, '127.0.0.1'
  ), 'server is listening on 127.0.0.1:8080'
).call();
\end{lstlisting}

As you can see, \cit{RequestResponseEvent} is a node of the async tree that represents request listener, but it's not a simple argument or async object. \cit{RequestResponseEvent} implements \cit{Event} interface and it needs to be treated in a special way, so it requires more flexibility of the whole system.

\subsection{Sequence of the async compositions}

Sometimes it's not so easy to make a proper composition of async objects(or just any kind of objects), mostly because sometimes we need to do completely different things at different moments. And if you try to combine these things in one async tree, you'll probably fail. So it would be very useful to be able call one async tree after another one. For example,

\begin{lstlisting}
new EqualAssertion(
  new ReadContentFromFile(
    new WrittenFile('./text.txt', 'content')
  ), 'content'
).after(
  RemovedFile('./text.txt')
).call();
\end{lstlisting}

It's a test that checks that read content from a file is equal to the content that has been written into there. After test the file can be removed to free space on a disk.

Method \cit{after} can be used only once for every async tree:

\begin{lstlisting}
// RIGHT WAY, pseudocode
AsyncTree1().after(
  AsyncTree2().after(
    AsyncTree3().after(...)
  )
)

// WRONG WAY, pseudocode
AsyncTree1().after(
  AsyncTree2()
).after(
  AsyncTree3()
).after(...)
\end{lstlisting}

\subsection{Cache mechanism}

Consider the following example with async tree:

\begin{lstlisting}
new SavedNewAccountOfUser(
  new RetrievedUser(userId),
  new RetrievedOldAccountOfUser(
    new RetrievedUser(userId)
  )
).call();
\end{lstlisting}

So, here we try to save new account for user that based(somehow) on its old one. And as you can see, we \textit{retrieve user} here twice. \cit{RetrievedUser} might be a quite expensive operation, so we don't want to do it more than one time. So, what would do you do here?

Well, you definitely don't want to do something like this:

\begin{lstlisting}
const retrievedUser = new RetrievedUser(userId);
new SavedNewAccountOfUser(
  retrievedUser,
  new RetrievedOldAccountOfUser(
    retrievedUser
  )
).call();
\end{lstlisting}

Because it does not change anything. All these objects are asynchronous, they are not simple procedures, and all them will be invoked only when they are needed in the async tree. It means that the results they produce could be received and used only in the inner scope of the tree.

Another thing you must consider here is which of two \cit{RetrievedUser} will be invoked first, so that you can write its result into the cache for using it for the second \cit{RetrievedUser}.

Here \textit{sequence of the async compositions} can help to create declarative construction for caching:

\begin{lstlisting}
new RetrievedUser(userId).as('user')
  .after(
    new SavedNewAccountOfUser(
      as('user'),
      new RetrievedOldAccountOfUser(
        as('user')
      )
    )
  ).call();
\end{lstlisting}

Every async object can has \cit{as(key)} method, which says to the async object that it must save its represented \textit{value(result)} into the cache with the specified \cit{key}. If \cit{as(key)} method is used as independent(separate) function, it returns async object that represents value from the cache with the specified \cit{key}.

\section{Implementation of the Async Tree}

\subsection{How it works}

The solution is quite simple. First of all, we need to replace async/sync calls with async objects for creating a composition of the async objects. The composition of these async objects need to be converted to an "asynchronous tree" for making tree traversal from its leaves to the root.

So, let's say we have following composition of async objects:

\begin{lstlisting}
//Pseudocode
A1 (
  A2 (
    a1, a2
  ),
  A3 (
    a3, A4(
      a4, a5
    )
  ),
  A5()
)
\end{lstlisting}
where \cit{A1}, \cit{A2}, \cit{A3}, \cit{A4}, \cit{A5} are async objects and \cit{a1}, \cit{a2}, \cit{a3}, \cit{a4}, \cit{a5} are just simple arguments. 

Then corresponding async tree for this composition would be:

\vspace*{10px}
\includegraphics[width=11cm, height=8cm]{async-tree.png}
\vspace*{10px}

Every node has child nodes as their arguments. So, \cit{a1}, \cit{a2}, \cit{a3}, \cit{a4}, \cit{a5}, \cit{A5} are \textit{leaves} of the tree and they are being called first at the same time. When their results are received, their parents will be ready to be invoked (\cit{a1}, \cit{a2}, \cit{a3}, \cit{a4}, \cit{a5} are already ready in that case, so we just add them to the arguments of their parent).

\cit{A1} is a root of the tree, so we invoke it last. \cit{A2} never waits for the results of \cit{A3} or \cit{A4}, because \cit{A2} just does not need them. But \cit{A3} waits for the result of \cit{A4}, and \cit{A1} waits for the results of \cit{A2}, \cit{A3} and \cit{A5}.

So, the sequence of the calls would look like this:

\begin{lstlisting}
a1, a2, a3, a4, a5, A5 // at the same time
A2, A4 // at the same time
A3
A1
\end{lstlisting}

You might ask \textit{"What if I need to use the result that is represented by the \cit{A1}, how can I do that?"}. Well, it's very simple: you just wrap it with another async object that processes representation of the \cit{A1}.

\section{Program implementation}

For implementation Aync Tree Pattern we need following classes(abstractions): \cit{AsyncObject}, \cit{AsyncTree},
\cit{TreeNode}, \cit{SimpleTreeNode}, \cit{AsyncTreeNode}, \cit{NotDefinedAsyncTreeNode}, \cit{Event}, \cit{As} and \cit{NullError}.

\subsection{AsyncObject}

\cit{AsyncObject} has three types of methods: methods that must be(or can be) implemented by classes that extend it, methods that can be used in declarative composition and methods that are not allowed to be overridden(for internal usage). Also \cit{AsyncObject} has constructor.

\vspace*{10px}
\noindent
\textbf{Constructor}

\begin{lstlisting}
constructor(...args) {
  this.args = args;
  this.next;
  this.cache = {};
  this.asKey;
}
\end{lstlisting}
\cit{...args} can be any type, including \cit{AsyncObject}. Argument \cit{next} points to the next async tree if it set by \cit{after} method(by default it's undefined). Also every async object has \cit{cache} that is simple map. It's needed because cache must be visible in the global scope. Field \cit{asKey} is used as a key for saving representation(computing result) of the async object into the cache if method \cit{as} is invoked.

\vspace*{10px}

\subsubsection{Methods for implementing}

\begin{lstlisting}
definedAsyncCall() {
  throw new Error('asyncCall or syncCall must be defined');
}

definedSyncCall() {
  throw new Error('asyncCall or syncCall must be defined');
}

onError(error) {
  throw error;
}

onResult(result) {
  return result;
}

onErrorAndResult(error, result) {
  return error || result;
}

continueAfterFail() {
  return false;
}

callbackWithError() {
  return true;
}
\end{lstlisting}

Either of methods \cit{definedAsyncCall} or \cit{definedSyncCall} must be defined(implemented) in extended classes. If both of them are implemented then only \cit{definedAsyncCall} will be invoked. \cit{definedAsyncCall} is used for async calls, so it must return function of the async call. \cit{definedSyncCall} is used for synchronous processing, so it must return blocking function. The entire logic of using these methods will be shown in the \cit{AsyncTreeNode} class. 

Method \cit{onError} is used as a handler for errors that might happen in the async calls. And \cit{onResult} is used for post processing of the result of async/sync call.

If \cit{continueAfterResult} returns true, then \cit{onError} and \cit{onResult} will be ignored, and the represented result(or an error) of async object will be returned by \cit{onErrorAndResult}.

Method \cit{callbackWithError} must return \cit{true} if an error is expected in the callback of corresponding async call, otherwise it must return \cit{false}.

\vspace*{10px}

\subsubsection{Methods from public API}

\begin{lstlisting}
call() {
  this.propagateCache(this);
  new AsyncTree(this).create().call();
}

after(asyncObject) {
  this.next = asyncObject;
  return this;
}

as(key) {
  this.asKey = key;
  return this;
}
\end{lstlisting}

Method \cit{call} is being invoked only of async object that is root of async tree. It propagates cache among all fields, so it will be able to access cache in every async object in the composition. The main point of this method is to create an async tree with root as this async object and invoke it.

Method \cit{after} is used for setting next async tree that is being invoked after the current one and returns this async object. Obviously, this method can be used only for the root async object.

Method \cit{as} is used for setting \cit{key} for caching. It returns the async object with set \cit{key}.

\vspace*{10px}

\subsubsection{Internal methods (not for overriding)}

\begin{lstlisting}
iterateArgs(func) {
  this.args.forEach((arg, index) => {
    let isAsync = arg instanceof AsyncObject;
    let isEvent = arg instanceof Event;
    func(arg, index, isAsync, isEvent);
  });
}

hasNoArgs() {
  return this.args.length === 0;
}

readyToBeInvoked(readyResultsNum) {
  return this.args.length === readyResultsNum;
}

callNextTreeIfExists() {
  if (this.next) {
    this.propagateCache(this.next);
    new AsyncTree(this.next).create().call();
  }
}

propagateCache(arg) {
  if (arg instanceof AsyncObject) {
    arg.withCache(this.cache);
    arg.iterateArgs(
      arg => this.propagateCache(arg)
    );
  }
}

withCache(cache) {
  this.cache = cache;
  return this;
 }
 
saveValueIntoCacheIfNeeded(value) {
  if (this.asKey) {
    this.cache[this.asKey] = value;
  }
  return this;
}
\end{lstlisting}

Method \cit{iterateArgs} is a proxy method, which avoid using \textit{getters} and \textit{setters} for processing \cit{...args} of the async object.

Method \cit{hasNoArgs} checks if async object encapsulates anything.

Method \cit{readyToBeInvoked} compares number of ready results that are computed by child nodes(\cit{...args}) and number of all \cit{..args}. If they are equal, that means that we can compute result of this async object.

Method \cit{callNextTreeIfExists} is used for calling next async tree if it exists.

Method \cit{propagateCache} is a recursive method that share the cache object among all async objects in the composition(or in the sequence of the async compositions).

Method \cit{withCache} attaches cache to this async object and returns it.

Mathod \cit{saveValueIntoCacheIfNeeded} save represented value of this async object into the cache, if this object has set \cit{asKey}.

\vspace*{10px}

\subsection{AsyncTree}

We need to convert async composition to the \cit{AsyncTree} to be able to use results of the async objects in this composition that are being computed by the corresponding async/sync calls. \cit{AsyncTree} has constructor, public and private methods.

\subsubsection{Constructor}

\begin{lstlisting}
constructor(rootField) {
  this.rootField = rootField;
  this.nodes = [];
}
\end{lstlisting}

Constructor has only one argument - \cit{rootField}, which is \cit{AsyncObject} that wraps all other async objects in the composition. Also constructor encapsulates \cit{nodes}, which is array that can contain elements with \cit{AsyncTreeNode} type and \cit{SimpleTreeNode} type.

\vspace*{10px}

\subsubsection{Public methods}

\begin{lstlisting}
create() {
  this.createAsyncTreeNode(this.rootField, new NotDefinedAsyncTreeNode(), 0);
  return this;
}

call() {
  let leaves = this.nodes.filter(node => {
    return node.isLeaf();
  });
  leaves.forEach(leaf => {
    leaf.call();
  });
}
\end{lstlisting}

Method \cit{create} use private recursive method \cit{createAsyncTreeNode} to create a root that creates other nodes later recursively. The method returns created \cit{AsyncTree}.

Method \cit{call} filters \cit{nodes} to call \cit{leaves} of this async tree. Then these leaves will call other nodes as it explained in the section 6.1.

\vspace*{10px}

\subsubsection{Private methods}

\begin{lstlisting}
createAsyncTreeNode(field, parent, index) {
  let asyncTreeNode = new AsyncTreeNode(field, parent, index);
  this.nodes.push(asyncTreeNode);
  this.createChildNodes(field, asyncTreeNode);
}

createSimpleTreeNode(field, parent, index) {
  let treeNode = new SimpleTreeNode(field, parent, index);
  this.nodes.push(treeNode);
}

createChildNodes(field, parent) {
  field.iterateArgs((argAsField, index, isAsync, isEvent) => {
    if (isAsync) {
      this.createAsyncTreeNode(argAsField, parent, index);
    } else if (isEvent) {
      this.createSimpleTreeNode((...eventArgs) => {
        argAsField.definedBody(...eventArgs);
      }, parent, index);
    } else {
      this.createSimpleTreeNode(argAsField, parent, index);
    }
  });
}
\end{lstlisting}

The main point of these private methods to create all \cit{nodes} for this async tree. \cit{nodes} can be two types: \cit{AsyncTreeNode} and \cit{SimpleTreeNode}. \cit{AsyncTreeNode} is used for async objects in the composition that is being converted to the async tree. \cit{SimpleTreeNode} is used for simple objects, primitives and events. Every node encapsulates three arguments: \cit{field} - the element in the async composition that is being wrapped around by this node, \cit{parent} is a node that is parent for this node and \cit{index} that points to the position of this node in the list of child nodes of the parent node. 

\vspace*{10px}

\subsection{TreeNode}

\cit{TreeNode} is an abstract class(or interface) that has constructor, methods that must be implemented in the extended classes(\cit{AsyncTreeNode}, \cit{SimpleTreeNode}) and method, which is not allowed to be overridden.

\subsubsection{Constructor}

\begin{lstlisting}
constructor(field, parent, position) {
  this.field = field;
  this.parent = parent;
  this.position = position;
}
\end{lstlisting}

\cit{Constructor} has three arguments and they have the same meaning that it's been explained for arguments of \cit{AsyncTreeNode} and \cit{SimpleTreeNode}.

\vspace*{10px}

\subsubsection{Methods for implementation}

\begin{lstlisting}
call(result) {
  throw new Error('call must be overridden');
}

isLeaf() {
  throw new Error('isLeaf must be overridden');
}
\end{lstlisting}

Method \cit{call} is used for retrieving result for this node and calling parent node if all needed results are ready.

Method \cit{isLeaf} is used for checking if this node is a leaf in the async tree that contains this node.

\vspace*{10px}

\subsubsection{Internal functionality (not for overriding)}

\begin{lstlisting}
callParent(result) {
  this.parent.insertArgumentResult(this.position, result);
  if (this.parent.readyToBeInvoked()) {
    this.parent.call();
  }
}
\end{lstlisting}

Method \cit{callParent} save result from this node by the position it has. And if all results are set, parent is being invoked.

\vspace*{10px}

\subsection{AsyncTreeNode}

\cit{AsyncTreeNode} is an implementation of the \cit{TreeNode}. And it has some additional public and private methods.

\subsubsection{Constructor}

\begin{lstlisting}
constructor(field, parent, position) {
  super(field, parent, position);
  this.argResults = [];
  this.readyResultsNum = 0;
}
\end{lstlisting}

The argument \cit{field} of this class can be only \cit{AsyncObject}. Also constructor stores the results that have been retrieved from the child nodes in the \cit{argResults} array. The parameter \cit{readResultsNum} is number of results that are ready to be used for the parent node.

\vspace*{10px}

\subsubsection{Public methods}

\begin{lstlisting}
call() {
  let args = this.argResults;
  try {
    let asyncCall = this.field.definedAsyncCall();
    if (this.field.callbackWithError()) {
      this.invokeAsyncCallWithError(asyncCall, ...args);
    } else {
      this.invokeAsyncCallWithoutError(asyncCall, ...args);
    }
  } catch(error) {
    if (error.message !== 'asyncCall or syncCall must be defined') {
      this.field.onError(error);
    } else {
      let syncCall = this.field.definedSyncCall();
      this.invokeSyncCall(syncCall, ...args);
    }
  }
}

isLeaf() {
  return this.field.hasNoArgs();
}

readyToBeInvoked() {
  return this.field.readyToBeInvoked(this.readyResultsNum);
}

hasParent() {
  return this.parent instanceof AsyncTreeNode;
}

insertArgumentResult(position, result) {
  this.argResults[position] = result;
  this.readyResultsNum += 1;
}
\end{lstlisting}

Method \cit{call} checks if async call is defined, if yes then it get result from it. If async call is not defined it checks if sync call is defined and use it for retrieving the result it provides. If some error happens in the definition of the async/sync call, it will be handled by the \cit{onError} method of the async object(it just throws the error by default).

Method \cit{isLeaf} checks if this node is a leaf by the number of arguments of this \cit{field}. If this number is zero, it's a leaf.

Method \cit{readyToBeInvoked} checks if all results from the child nodes are ready by the \cit{readyResultsNum}.

Method \cit{hasParent} checks if this node has a parent node. Only \cit{AsyncTreeNode} can has child node.

Method \cit{insertArgumentResult} inserts a result of one of the child nodes to the \cit{argResults} and increments \cit{readyResultsNum}.

\vspace*{10px}

\subsubsection{Private methods}

\begin{lstlisting}
invokeAsyncCallWithError(asyncCall, ...args) {
  asyncCall(...args, (error, ...results) => {
    if (!this.processedError(error, ...results)) {
      this.processedResult(...results);
    }
  });
}

invokeAsyncCallWithoutError(asyncCall, ...args) {
  asyncCall(...args, (...results) => {
    this.processedResult(...results);
  });
}

invokeSyncCall(syncCall, ...args) {
  try {
    let syncCallResult = syncCall(...args);
    this.processedResult(syncCallResult);
  } catch (error) {
    this.processedError(error);
  }
}

processedError(error, ...results) {
  let isProcessed = false;
  // It's not possible to get rid of null here :(
  if (error != null) {
    if (this.hasParent()) {
      if (this.field.continueAfterFail()) {
        let totalResult = this.field.onErrorAndResult(error, ...results);
        this.field.saveValueIntoCacheIfNeeded(totalResult);
        super.callParent(totalResult);
      } else {
        this.field.onError(error);
      }
    } else {
      if (this.field.continueAfterFail()) {
        let totalResult = this.field.onErrorAndResult(error, ...results);
        this.field.saveValueIntoCacheIfNeeded(totalResult);
        this.field.callNextTreeIfExists();
      } else {
        this.field.onError(error);
      }
    }
    isProcessed = true;
  }
  return isProcessed;
}

processedResult(...results) {
  let totalResult;
  if (this.hasParent()) {
    if (this.field.continueAfterFail()) {
      totalResult = this.field.onErrorAndResult(new NullError(), ...results);
    } else {
      totalResult = this.field.onResult(...results);
    }
    this.field.saveValueIntoCacheIfNeeded(totalResult);
    super.callParent(totalResult);
  } else {
    if (this.field.continueAfterFail()) {
      totalResult = this.field.onErrorAndResult(new NullError(), ...results);
    } else {
      totalResult = this.field.onResult(...results);
    }
    this.field.saveValueIntoCacheIfNeeded(totalResult);
    this.field.callNextTreeIfExists();
  }
  return true;
}
\end{lstlisting}

Method \cit{invokeAsyncCallWithError} invokes defined async call of the field, which is an async object with a callback that uses an error argument.

Method \cit{invokeAsyncCallWithoutError} does the same that \cit{invokeAsyncCallWithError} does but it uses a callback without error parameter.

Method \cit{invokeSyncCall} invokes defined sync call of the field, which is an async object(although it defines sync call).

Methods \cit{processedResult} and \cit{processedError} are used for processing and post processing the result or an error from the async/sync call considering the configuration of the field. These methods also decide what to save into the cache if it's needed and invoke next async tree if it exists.

\vspace*{10px}

\subsection{SimpleTreeNode}

\cit{SimpleTreeNode} also implements(or extends) \cit{TreeNode}.

\subsubsection{Constructor}

\begin{lstlisting}
constructor(field, parent, position) {
  super(field, parent, position);
}
\end{lstlisting}

Unlike \cit{AsyncTreeNode}, \cit{SimpleTreeNode} has a \cit{field} that is just simple object or primitive. And as it's been said before, \cit{parent} is always \cit{AsyncTreeNode}.

\vspace*{10px}

\subsubsection{Public methods}

\begin{lstlisting}
call() {
  super.callParent(this.field);
}

isLeaf() {
  return true;
}
\end{lstlisting}

The main point of the method \cit{call} is to call parent node, if it's ready to be invoked.

\cit{SimpleTreeNode} is always a leaf because it cannot be a parent node, so method \cit{isLeaf} always returns \cit{true}.

\vspace*{10px}

\subsection{NotDefinedAsyncTreeNode}

The root of a tree has no parent node and it's not good to use \cit{null} for this declaration. It's better to create an object that indicates that node is not defined.  

\subsection{Event}

\cit{Event} is an interface that provides only one method: \cit{definedBody(...args)} that must be implemented by the extended classes. The main purpose of this interface is to replace functions of events(or listeners). \cit{Event} is not an \cit{AsyncObject}, but it represents function of some event. But you cannot use \cit{AsyncObject} that represents some \cit{Event} instead of the \cit{Event}. In that case you can use \cit{AsyncObject} that represents some function. Actually, you can use a function in the async composition instead of \cit{Event}, but for readability it's better to use \cit{Event}.

\begin{lstlisting}
definedBody(...args) {
  throw new Error('Method definedBody must be overridden with arguments of the event/eventListener you call');
}
\end{lstlisting}

\subsection{As}

\cit{As} is an \cit{AsyncObject} that represents a result from the cache by the \cit{key}.

\subsubsection{Implementation}

\begin{lstlisting}
constructor(key) {
  super(key);
}

definedSyncCall() {
  return (key) => {
    let result = this.cache[key];
    if (!result) {
      throw new Error(`There is no value that is cached with key: \${key}`);
    }
    return result;
  }
}
\end{lstlisting}

Since \cit{cache} is visible among all async objects and \cit{As} is an \cit{AsyncObject}, we can use it in the definition of the sync call. For more readability it's better to use function \cit{as} that returns \cit{As}:

\begin{lstlisting}
module.exports = (key) => {
  return new As(key);
};

//then in the code where it's required:
const as = require('./As');
\end{lstlisting}

\vspace*{10px}

\subsection{NullError}

This class is for avoiding \cit{null} constant in the code for errors. 

\begin{lstlisting}
class NullError extends Error {

  constructor() {
    super('It is a null error');
    this.isNull = true;
  }

}
\end{lstlisting}

\section{How to create AsyncObject}

\subsection{For async call}

Let's take async call \cit{read} from the \cit{fs} module in Node. It has following signature:

\begin{lstlisting}
fs.read(fd, buffer, offset, length, position, (bytesRead, buffer) => {
  // handle bytesRead and buffer
});
\end{lstlisting}

As you can see we have two things to handle in the callback: \cit{bytesRead}, \cit{buffer}. But \cit{AsyncObject} must represent only one object. So you can create an object that contains everything that callback provides: \cit{{bytesRead, buffer}} or you can choose something that's needed for you. Let's say we need only a \cit{buffer} from the callback, so we would name our \cit{AsyncObject} something like \cit{ReadBufferByFD}.

Let's look on how it must be implemented:

\begin{lstlisting}

const AsyncObject = require('./AsyncObject');
const fs = require('fs');

// Represented result is buffer
class ReadBufferByFD extends AsyncObject {

  constructor(fd, buffer, offset, length, position) {
    super(fd, buffer, offset, length, position);
  }

  definedAsyncCall() {
    return fs.read;
  }

  onResult(bytesRead, buffer) {
    return buffer;
  }

}
\end{lstlisting}

First of all, we extends \cit{ReadBufferByFD} from \cit{AsyncObject}. Constructor has the same parameters as corresponding async call has except callback, we don't need to pass it there. Every of these might be or not an \cit{AsyncObject}. 

Then we need to define async call, so it must return \cit{fs.read}. It's also possible to write this definition in the explicit way:

\begin{lstlisting}
definedAsyncCall() {
  return (fd, buffer, offset, length, position, callback) => {
    return fs.read(fd, buffer, offset, length, position, callback);
  }
}
\end{lstlisting}

Unlike in the constructor here parameters \cit{fd}, \cit{buffer}, \cit{offset}, \cit{length}, \cit{position} are definitely ready results(not async objects), so it's possible to use them in the procedural style. Also you need a \cit{callback} parameter here, because it's needed for the async call.

In the method \cit{onResult} (that provides the same that callback of the async call provides) we return \cit{buffer}. So, it means that this async object represents buffer.

\subsection{For sync call}

Let's now consider a sync variation of the \cit{fs.read}. It's a sync method \cit{fs.readSync}. It has similar signature that \cit{fs.read} has: 

\begin{lstlisting}
fs.readSync(fd, buffer, offset, length, position);
\end{lstlisting}

This sync call returns \cit{bytesRead} and it changes \cit{buffer} that has been passed there. So, we have following implementation:

\begin{lstlisting}
// Represented result is buffer
class ReadBufferByFDSync extends AsyncObject {

  constructor(fd, buffer, offset, length, position) {
    super(fd, buffer, offset, length, position);
  }

  definedSyncCall() {
    return (fd, buffer, offset, length, position) => {
      fs.readSync(fd, buffer, offset, length, position);
      return buffer;
    }
  }

}
\end{lstlisting}

Here we must use explicit definition of the sync call in the \cit{definedSyncCall} method, because we need to return buffer. And we don't need to a callback because it's a synchronous operation. Here we don't need to override \cit{onResult} method, because we override here the sync call that returns what we need.

\subsection{Why don't use SyncObject abstraction for the sync calls?}

Two reasons. First of them is technical reason: it's just easier to implement \cit{AsyncObject} that can wrap either sync or async call. 

Second reason is logical: although \cit{AsyncObject} can wrap sync call, it might require parameters that have been retrieved from the asynchronous operations, so it means that this async object actually has asynchronous nature, because it can be invoked only after some async operations.

More over, even if \cit{AsyncObject} wraps sync call it belongs to some \cit{AsyncTree} or async composition.

\section{How to create an Event}

Let's say we have a \cit{ReadStream} and we need to be able to attach a 'open' event to it. So, we need to create an async object \cit{ReadStreamWithOpenEvent} that represents \cit{ReadStream} with attached 'open' event.

\begin{lstlisting}
// Represented result is a ReadStream
class ReadStreamWithOpenEvent extends AsyncObject {

  /*
    event is an Event with definedBody(fd)
  */
  constructor(readStream, event) {
    super(readStream, event);
  }

  definedSyncCall() {
    return (readStream, event) => {
      readStream.on('open', event);
      return readStream;
    }
  }

}
\end{lstlisting}

Actually \cit{readStream} with 'open' event has the following signature:

\begin{lstlisting}
readStream.on('open', (fd) => {
    
    // here we work with fd
    
});
\end{lstlisting}

So, \cit{OpenEvent} would be:

\begin{lstlisting}
class OpenEvent extends Event {

  constructor() {
    super();
  }

  definedBody(fd) {
    // here we work with fd
  }

}
\end{lstlisting}

As you can see \cit{definedBody} use the same arguments as the event of the \cit{readStream}. 

So, in the composition it would look something like this:

\begin{lstlisting}
new ReadStreamWithOpenEvent(
  new CreatedSomeHowReadStream(), new OpenEvent()
).call();
\end{lstlisting}

\section{Example of using the sequence of async compositions and cache mechanism}

Let's consider following async object:

\begin{lstlisting}
class MaxNum extends AsyncObject {

  constructor(...args) {
    super(...args);
  }

  definedSyncCall() {
    return (...args) => {
      return Math.max(...args);
    }
  }

}
\end{lstlisting}

\cit{MaxNum} represent the max of the specified numbers.

And we have async object that wraps \cit{assert.strictEqual} function that asserts that two numbers are equal:

\begin{lstlisting}
class StrictEqualAssertion extends AsyncObject {

  constructor(actual, expected) {
    super(actual, expected);
  }

  definedSyncCall() {
    return (actual, expected) => {
      assert.strictEqual(actual, expected);
      return actual;
    }
  }

}
\end{lstlisting}

So, let's have some fun:

\begin{lstlisting}
new MaxNum(
  new MaxNum(1, 2, 4).as('max1'), 5, 
  new MaxNum(
   new MaxNum(4, new MaxNum(3, 4, 6)).as('max2'), 7, 8
  ).as('max3')
).after(
  new StrictEqualAssertion(
    new MaxNum(as('max1'), as('max2'), as('max3')), 8 
  )
);
\end{lstlisting}

It's a silly example but it shows the power of the Async Tree Pattern.

\section{Conclusion}

Async Tree Pattern is very useful design pattern if you care about readability and beauty of your code. It allows to describe the whole program as a tree that contains a lot of little independent pieces, each of them is responsible for something little functionality. So, the whole conception satisfies \textit{single responsibility principle}. Async tree allows to hide the details of how a program works under the cute declarative composition, which is easy to read and maintain.

In this work it's been shown and described how to implement and use Async Tree Pattern. Actually, you don't need to implement this pattern by yourself, it's available in the \textbf{Cutie} library(link on this library is in the \textbf{References} section). 

\section{References}

\begin{thebibliography}{9}

\bibitem{yegor256-cdium} 
Yegor Bugayenko: Composable Decorators vs. Imperative Utility Methods,
\\\texttt{https://www.yegor256.com/2015/02/26/composable-decorators.html}

\bibitem{srp} 
Single responsibility principle,
\\\texttt{https://en.wikipedia.org/wiki/Single\_responsibility\_principle}

\bibitem{yegor256-w} 
Yegor Bugayenko: What's Wrong With Object-Oriented Programming?,
\\\texttt{https://www.yegor256.com/2016/08/15/what-is-wrong-object-oriented-programming.html}

\bibitem{yegor256-wn} 
Yegor Bugayenko: Why NULL is Bad?,
\\\texttt{https://www.yegor256.com/2014/05/13/why-null-is-bad.html}

\bibitem{guseyn-r} 
Guseyn Ismayylov: Cutie library: reconsidering the concept of the async objects,
\\\texttt{http://guseyn.com/post-reconsidering-async-object-with-cutie}

\bibitem{guseyn-d} 
Guseyn Ismayylov: Declarative events,
\\\texttt{http://guseyn.com/post-event-new-abstraction-in-cutie}

\bibitem{guseyn-s} 
Guseyn Ismayylov: Sequence of async trees (improved cache mechanism),
\\\texttt{http://guseyn.com/post-after-conception}

\bibitem{guseyn} 
Cutie library,
\\\texttt{https://github.com/Guseyn/cutie}

\end{thebibliography}

\newpage

\tableofcontents

\end{document}
