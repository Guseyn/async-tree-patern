\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\newcommand{\cit}[1]{{\fontfamily{qcr}\selectfont{\textit{\textbf{\textcolor{darkgray}{#1}}}}}}

% Taken from Lena Herrmann at 
% http://lenaherrmann.net/2010/05/20/javascript-syntax-highlighting-in-the-latex-listings-package
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}

\title{Async Tree Pattern}
\author{Guseyn Ismayylov}
\date{July 2018}

\begin{document}

\maketitle

\section{Introduction}

\textbf{Async Tree Pattern} is a declarative design pattern, the main purpose of which is to transform procedural code into the object-oriented(declarative) code in the asynchronous environment (in this work implementation of this pattern will be shown for Node.js).

Also \textbf{Async Tree} can be considered as a data structure.
\section{Declarative vs Imperative}

The conception of the \textbf{Async Tree} was created with assumption that declarative programming is much better than imperative style of writing code for big programs and systems. Declarative code is more readable, extensible and maintainable in general.

You may agree or disagree with this statement. It's only opinion of the author of this work.

Here it will be shown the difference between these two approaches by small example. Let's consider the following imperative code:  

\begin{lstlisting}
// Imperative
user = getUserFromDb(userId);
account = user.createNewAccount(accountInfo);
user.saveAccount(account);
\end{lstlisting}

It can be written in the declarative style:

\begin{lstlisting}
// Declarative
SavedAccount(
  CreatedAccount(
    UserFromDb(userId), accountInfo
  )
).call();
\end{lstlisting}

The example is quite small to demonstrate why declarative programming is preferable. Nevertheless, you can see that declarative code always shows the result of program execution and what it requires to get this result. For readability it's more important to be able to see what result you get, not how exactly you get it.

\section{Why Node.js}

As it's been said the implementation of the \textbf{Async Tree} will be described for Node.js. The choice is very simple because Node.js is the most popular and stable asynchronous  event driven runtime and it performs well. But as you will see, \textbf{Async Tree} can be applied not only in the asynchronous environment.

\section{Async Tree and Async Object}

\textbf{Async Tree} can be defined as a composition of objects and primitives. Each of objects in this composition that represents some other object or primitive type of data is called \textbf{Async Object}. 

For example, in the previous example \cit{SavedAccount} and \cit{CreatedAccount} represent \cit{Account}, \cit{UserFromDb} represents \cit{User}.

\textbf{Async Object} is an object that represents(computes) some other but similar(in terms of logic) object. So, for example, \cit{SavedAccount}, \cit{UpdatedAccount}, \cit{DeletedAccount} are \textit{async objects} because they represent \cit{Account}, which is simple object. \cit{UserFromDb}, \cit{UserFromRequest} are also \textit{async objects}, they represent simple object \cit{User}.

Every \textbf{Async Object} can be constructed by other \textit{async objects}, \textit{simple objects} and \textit{primitives}. For example, \cit{SavedAccount} can be created by \cit{UpdatedAccount}, \cit{CreatedAccount} or any other \cit{Async Object} that represents \cit{Account}. Obviously, it can be created by \cit{Account} itself.

That's the main idea of the \textbf{Async Tree Pattern}: to provide flexible way to create composition of objects via their representations.

\section{Asynchronous environment and \textit{callback hell}}

If you're familiar with Node.js and how it works, you might know about \textit{callback hell} hell problem. Callbacks is the main feature and problem in Node.js. Although it's a beautiful abstraction, it decreases readability of a program while it grows up.

Actually, \textit{callback hell} is one of reasons why \textbf{Async Tree Pattern} was created. There are relatively new conceptions in JavaScript like Promises and async/await. But in my opinion, these abstractions are not suitable for object-oriented style. Simply because they don't provide the main feature of OOP: encapsulation. 
It's not possible to create a composition of objects and write declarative code with these abstractions.

Node.js is a set of modules with static asynchronous methods. And this is main problem, static methods are not actually attached to any objects. They exists in namespaces such as fs(Node.js module for file system), http, stream, buffer and so on.

Static methods with callbacks don't allow to use results of their execution for other operations in the explicit way. The more asynchronous calls in code, the harder to control flow of data there.

Let's say we want to write content to a file that has been read from another one. And all these operations are asynchronous, of course. So, instead of writing something like this:

\begin{lstlisting}
fs.readFile('./../file1.txt', 'utf8', (err, result) => {
  if (err != null) {
    throw err;
  }
 
  fs.writeFile('/../file2.txt', result, (err) => {
    if (err != null) {
      throw err;
    }
  });
});
\end{lstlisting}

we can design our code in the following style:

\begin{lstlisting}
new WrittenFile(
  './../file2.txt',
  new ReadContentFromFile('./../file1.txt', 'utf8')
).call();
\end{lstlisting}

As you can see, we use \textit{async objects} instead of \textit{async calls} and their representations as results of operations they correspond to. So, \cit{ReadContentFromFile} represents \cit{string} - content from a file, which is result of \textit{async call} \cit{fs.readFile}. And \cit{WrittenFile} represents a file that has been written with some content. Although \cit{fs.WriteFile} does not return anything, we can use \cit{WrittenFile} as file for other operations if it's needed.

\section{Features of the Async Object}

For implementation of the \textbf{Async Tree Pattern} 

1) Replaceable and flexible: can be constructed by async objects and objects that they represent + primitives.

2) has cache

3) is used instead of callbacks

4) method call

5) fail or success, fail fast and continue after fail


\section{Events}

\section{Cache mechanism}

\section{Implementation of the Async Tree}

1) AsyncObject

2) AsyncTree

3) TreeNode, SimpleTreeNode, AsyncTreeNode, NotDefinedAsyncTreeNode.js

4) Event

5) As

6) NullError

\end{document}
